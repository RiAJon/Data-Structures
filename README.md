# Data-Structures
Each data structure has various advantages and disadvantages when it comes to inserting, searching, and sorting. 

**Vectors** are straightforward to create and use, with insertion at the end of the vector having a constant runtime of O(1). Additionally, vectors can be dynamically resized depending on implementation needs. However, this resizing involves copying vector elements to a new location, which can be computationally expensive. A vector has a best case runtime for searching of O(1), assuming that the key matches the first element, but a worst case runtime of O(n), meaning every element must be checked. The best-case runtime should be considered uncommon.

**Hash tables** offer O(1) runtime for insertions and searches in the best case, which makes them very efficient. For this reason, they are suitable for large data sets where quick access to values is necessary. However, a high collision rate can degrade this performance to its worst case of O(n). This is a rare condition with a good Hash function, but any hash function will require significant memory and will not store elements in a particular order, which makes sorting unnecessarily time consuming. 

**Binary search trees** offer a great alternative when it comes to the sorting issue. Because data is stored in a sorted manner, ordered traversals are extremely simple. In balanced form, a binary search tree can insert and access elements with a runtime of O(log n) which makes it highly efficient. In the worst case, though, the runtime for these operations degenerates to O(n) like the other structures. Also, implementing a good tree is more difficult than other data structures and these trees require a decent amount of memory due to the pointers needed for each node.

Despite its disadvantages, I recommend a binary search tree for large data sets. Because a BST maintains sorted elements, printing the courses alphanumerically becomes a simple task. Searching with a key and inserting can be as efficient as O(log n), but at its worst, will be O(n) which is no worse than the other structures. The ordered, binary nature of the BST makes it ideal for balancing the functionality required by the advisors. It offers an efficient runtime for insertion and searching while not sacrificing speed for alphanumeric sorting like a vector or hash table would. 

## Binary Search Trees
The C++ Search Tree artifact is a binary search tree structure which implements insertion, deletion, search, and sort algorithms. It was created at SNHU for CS260: Data Structures and Algorithms. I selected this item for my portfolio because I was very interested in the process of creating different data storage structures and evaluating their efficiency in areas like searching and sorting. My professor in that class mentioned more complicated self-balancing trees but said that they were outside the scope of the class.

When the opportunity arose to revisit the data structure, I decided I wanted to expand my understanding of data structures and create a **red and black tree**. I wanted to be able to use the structure in some of my java projects, so I decided to complete the enhancement in java. I also decided to port the original binary search tree from C++ to java so that I could compare the efficiency of the structures with big O notation. This enhancement displays skills including the ability to port projects between OOP languages, algorithm design, efficiency analysis, and unit testing.

Porting the original tree helped me write the code for the red and black tree because the logic follows the same lines with an extra element in each storage node. The biggest challenge in the new implementation was learning how to create the self-balancing effect in the structure through rotation. Luckily, having just worked on the first tree, I had some fresh ideas about how to make the code clearer and reusable in the new tree. This included aspects like variable names, class data fields, function modules, and more.

![416422053-d563ddf1-288d-4c86-9ac2-337f7a31e8e4](https://github.com/user-attachments/assets/06c2dc09-388e-43e3-8992-0231ed0231d4)
